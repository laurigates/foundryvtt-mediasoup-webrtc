// mediasoup-vtt.js - Main file for the FoundryVTT MediaSoup Plugin

// +-------------------------------------------------------------------+
// |                      PLUGIN CONSTANTS                             |
// +-------------------------------------------------------------------+

const MODULE_ID = 'mediasoup-vtt';
const MODULE_TITLE = 'MediaSoupVTT';
const LOG_PREFIX = `${MODULE_TITLE} |`;

// Settings keys
const SETTING_MEDIASOUP_URL = 'mediaSoupServerUrl';
const SETTING_AUTO_CONNECT = 'autoConnect';
const SETTING_DEFAULT_AUDIO_DEVICE = 'defaultAudioDevice';
const SETTING_DEFAULT_VIDEO_DEVICE = 'defaultVideoDevice';
const SETTING_DEBUG_LOGGING = 'debugLogging';

// Media track kinds
const MEDIA_KIND_AUDIO = 'audio';
const MEDIA_KIND_VIDEO = 'video';

// AppData tags for producers
const APP_DATA_TAG_MIC = 'mic';
const APP_DATA_TAG_WEBCAM = 'webcam';


// Signaling message types (examples)
const SIG_MSG_TYPES = {
    GET_ROUTER_RTP_CAPABILITIES: 'getRouterRtpCapabilities',
    ROUTER_RTP_CAPABILITIES: 'routerRtpCapabilities',
    CREATE_WEBRTC_TRANSPORT: 'createWebRtcTransport',
    TRANSPORT_CREATED: 'transportCreated',
    CONNECT_TRANSPORT: 'connectTransport',
    TRANSPORT_CONNECTED: 'transportConnected',
    PRODUCE: 'produce',
    PRODUCED: 'produced',
    NEW_PRODUCER: 'newProducer', // Server notification: { producerId, userId, kind, appData (contains rtpParameters for consumption) }
    CONSUME: 'consume', // Client request: { producerId, rtpCapabilities, transportId (optional, server might pick) }
    CONSUMED: 'consumed', // Server response: { id (consumerId), producerId, kind, rtpParameters }
    PRODUCER_CLOSED: 'producerClosed', // Server notification or client action
    PAUSE_PRODUCER: 'pauseProducer',
    RESUME_PRODUCER: 'resumeProducer',
    CONSUMER_PAUSE: 'consumerPause', // Server telling client to pause a consumer
    CONSUMER_RESUME: 'consumerResume', // Server telling client to resume a consumer
    CONSUMER_CLOSE: 'consumerClose', // Server telling client to close a consumer
};

// +-------------------------------------------------------------------+
// |                      HELPER FUNCTIONS                             |
// +-------------------------------------------------------------------+

function log(message, level = 'info', force = false) {
    const settingDebug = game.settings.get(MODULE_ID, SETTING_DEBUG_LOGGING);
    if (level === 'debug' && !settingDebug && !force) return;
    const timestamp = new Date().toLocaleTimeString();
    const enrichedMessage = `[${timestamp}] ${message}`;
    switch (level) {
        case 'warn': console.warn(`${LOG_PREFIX} ${enrichedMessage}`); break;
        case 'error': console.error(`${LOG_PREFIX} ${enrichedMessage}`); break;
        case 'info': console.info(`${LOG_PREFIX} ${enrichedMessage}`); break;
        case 'debug': console.debug(`${LOG_PREFIX} ${enrichedMessage}`); break;
        default: console.log(`${LOG_PREFIX} ${enrichedMessage}`);
    }
}

// +-------------------------------------------------------------------+
// |                      MEDIASOUP CLIENT LOGIC                       |
// +-------------------------------------------------------------------+

class MediaSoupVTTClient {
    constructor() {
        this.device = null;
        this.socket = null;
        this.sendTransport = null;
        this.recvTransport = null;
        this.producers = new Map();
        this.consumers = new Map(); // Key: consumer.id, Value: consumer object

        this.serverUrl = game.settings.get(MODULE_ID, SETTING_MEDIASOUP_URL);
        this.isConnected = false;
        this.isConnecting = false;
        this.requestMap = new Map();
        this.requestIdCounter = 0;

        this.localAudioStream = null;
        this.localVideoStream = null;
        this.remoteUserStreams = new Map(); // Key: userId, Value: { audioTrack: MediaStreamTrack, videoTrack: MediaStreamTrack, audioConsumerId: string, videoConsumerId: string }

        if (!window.mediasoupClient) {
            log('mediasoup-client library is not loaded. This plugin will not function.', 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: mediasoup-client library not found! Critical error.`, { permanent: true });
        }
    }

    async connect() {
        // ... (connect method remains largely the same)
        if (this.isConnected || this.isConnecting) {
            log(`Cannot connect. Already connected or connecting. Connected: ${this.isConnected}, Connecting: ${this.isConnecting}`, 'warn');
            return;
        }
        if (!this.serverUrl) {
            log('MediaSoup server URL is not configured.', 'warn', true);
            ui.notifications.warn(`${MODULE_TITLE}: MediaSoup server URL not configured. Please set it in module settings.`);
            return;
        }
        if (!window.mediasoupClient) {
            log('mediasoup-client library not found. Cannot connect.', 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: mediasoup-client library not available. Cannot connect.`);
            return;
        }

        this.isConnecting = true;
        this._updateConnectionStatus('connecting');
        log(`Attempting to connect to MediaSoup server at ${this.serverUrl}...`);

        try {
            this.socket = new WebSocket(this.serverUrl);
            this.socket.onopen = async () => {
                log('WebSocket connection established.', 'info');
                await this._initializeMediasoupDevice();
            };
            this.socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    this._handleSignalingMessage(message);
                } catch (error) {
                    log(`Error parsing signaling message: ${error.message}`, 'error');
                    console.error("Raw message data:", event.data);
                }
            };
            this.socket.onerror = (error) => {
                log(`WebSocket error: ${error.message || 'Unknown error'}`, 'error', true);
                console.error('WebSocket error object:', error);
                ui.notifications.error(`${MODULE_TITLE}: WebSocket connection error.`);
                this._handleConnectionFailure();
            };
            this.socket.onclose = (event) => {
                log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason given'}`, event.wasClean ? 'info' : 'warn');
                if (!event.wasClean) {
                     ui.notifications.warn(`${MODULE_TITLE}: WebSocket connection closed unexpectedly.`);
                }
                this._handleConnectionFailure();
            };
        } catch (error) {
            log(`Failed to initiate WebSocket connection: ${error.message}`, 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: Failed to initiate connection.`);
            this._handleConnectionFailure();
        }
    }

    _handleConnectionFailure() {
        this.isConnecting = false;
        if (this.isConnected) {
            ui.notifications.info(`${MODULE_TITLE}: Disconnected from MediaSoup server.`);
        }
        this.disconnect(false);
        this._updateConnectionStatus('error');
    }

    async _initializeMediasoupDevice() {
        // ... (remains largely the same)
        try {
            log('Initializing mediasoup-client Device...');
            this.device = new window.mediasoupClient.Device();
            const routerRtpCapabilities = await this._sendSignalingRequest({ type: SIG_MSG_TYPES.GET_ROUTER_RTP_CAPABILITIES });
            if (!routerRtpCapabilities || Object.keys(routerRtpCapabilities).length === 0) {
                throw new Error('Received empty or invalid routerRtpCapabilities from server.');
            }
            log('Received Router RTP Capabilities. Loading into device...', 'debug');
            await this.device.load({ routerRtpCapabilities });
            log('Mediasoup Device loaded successfully.', 'info');

            await this._createSendTransport();
            await this._createRecvTransport();

            this.isConnected = true;
            this.isConnecting = false;
            this._updateConnectionStatus('connected');
            ui.notifications.info(`${MODULE_TITLE}: Successfully connected to MediaSoup server.`);
            await this._populateDeviceSettings();
            // After successful connection, explicitly render player list to show A/V status
            ui.players.render(true);


        } catch (error) {
            log(`Error initializing MediaSoup Device: ${error.message}`, 'error', true);
            console.error(error);
            ui.notifications.error(`${MODULE_TITLE}: Initialization failed - ${error.message}`);
            this._handleConnectionFailure();
        }
    }

    _sendSignalingRequest(requestData, timeoutMs = 10000) {
        // ... (remains largely the same)
        return new Promise((resolve, reject) => {
            if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                return reject(new Error('WebSocket is not open.'));
            }
            const requestId = `req_${this.requestIdCounter++}`;
            const message = { ...requestData, requestId, userId: game.userId }; 

            this.requestMap.set(requestId, { resolve, reject });
            log(`Sending signaling request (ID: ${requestId}): ${JSON.stringify(requestData)}`, 'debug');
            this.socket.send(JSON.stringify(message));

            setTimeout(() => {
                if (this.requestMap.has(requestId)) {
                    this.requestMap.delete(requestId);
                    log(`Signaling request (ID: ${requestId}, Type: ${requestData.type}) timed out.`, 'warn');
                    reject(new Error(`Request '${requestData.type}' timed out`));
                }
            }, timeoutMs);
        });
    }

    _handleSignalingMessage(message) {
        log(`Received signaling message: ${JSON.stringify(message)}`, 'debug');
        if (message.requestId && this.requestMap.has(message.requestId)) {
            const { resolve, reject } = this.requestMap.get(message.requestId);
            if (message.error) {
                log(`Signaling request (ID: ${message.requestId}) failed: ${message.error}`, 'error');
                reject(new Error(message.error));
            } else {
                resolve(message.data || message);
            }
            this.requestMap.delete(message.requestId);
            return;
        }
        switch (message.type) {
            case SIG_MSG_TYPES.NEW_PRODUCER:
                log(`Server notified of new producer: ${message.producerId} for user ${message.userId} of kind ${message.kind}`, 'info');
                this._handleNewRemoteProducer(message); // message should contain: producerId, userId, kind, appData (which includes rtpParameters for consumption)
                break;
            case SIG_MSG_TYPES.PRODUCER_CLOSED:
                log(`Server notified producer closed: ${message.producerId}`, 'info');
                this._handleRemoteProducerClosed(message.producerId);
                break;
            // Add cases for CONSUMER_PAUSE, CONSUMER_RESUME, CONSUMER_CLOSE if server sends these
            default:
                log(`Received unhandled signaling message type: ${message.type}`, 'warn');
        }
    }

    async _createSendTransport() { /* ... (no changes) ... */ 
        try {
            log('Requesting server to create send transport...', 'debug');
            const transportInfo = await this._sendSignalingRequest({
                type: SIG_MSG_TYPES.CREATE_WEBRTC_TRANSPORT,
                forceTcp: false, 
                producing: true,
                consuming: false,
                sctpCapabilities: this.device.sctpCapabilities 
            });

            if (!this.device) throw new Error("Device not initialized for creating send transport.");
            this.sendTransport = this.device.createSendTransport(transportInfo);
            log('Send transport created locally.', 'debug');

            this.sendTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                log('Send transport "connect" event triggered.', 'debug');
                try {
                    await this._sendSignalingRequest({
                        type: SIG_MSG_TYPES.CONNECT_TRANSPORT,
                        transportId: this.sendTransport.id,
                        dtlsParameters
                    });
                    callback(); 
                    log('Send transport connected to server.', 'info');
                } catch (error) {
                    log(`Error connecting send transport: ${error.message}`, 'error');
                    errback(error);
                }
            });

            this.sendTransport.on('produce', async ({ kind, rtpParameters, appData }, callback, errback) => {
                log(`Send transport "produce" event triggered for kind: ${kind}`, 'debug');
                try {
                    const { id } = await this._sendSignalingRequest({
                        type: SIG_MSG_TYPES.PRODUCE,
                        transportId: this.sendTransport.id,
                        kind,
                        rtpParameters,
                        appData 
                    });
                    callback({ id }); 
                    log(`Successfully produced ${kind} (Producer ID: ${id}, AppData: ${JSON.stringify(appData)})`, 'info');
                } catch (error) {
                    log(`Error on "produce" event for send transport: ${error.message}`, 'error');
                    errback(error);
                }
            });

            this.sendTransport.on('connectionstatechange', (state) => {
                log(`Send transport connection state changed: ${state}`, 'debug');
                if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                    log(`Send transport entered critical state: ${state}.`, 'warn');
                }
            });

        } catch (error) {
            log(`Error creating send transport: ${error.message}`, 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: Could not create send transport - ${error.message}`);
            this._handleConnectionFailure(); 
        }
    }
    async _createRecvTransport() { /* ... (no changes) ... */ 
         try {
            log('Requesting server to create receive transport...', 'debug');
            const transportInfo = await this._sendSignalingRequest({
                type: SIG_MSG_TYPES.CREATE_WEBRTC_TRANSPORT,
                forceTcp: false,
                producing: false,
                consuming: true,
                sctpCapabilities: this.device.sctpCapabilities
            });

            if (!this.device) throw new Error("Device not initialized for creating recv transport.");
            this.recvTransport = this.device.createRecvTransport(transportInfo);
            log('Receive transport created locally.', 'debug');

            this.recvTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                log('Receive transport "connect" event triggered.', 'debug');
                try {
                    await this._sendSignalingRequest({
                        type: SIG_MSG_TYPES.CONNECT_TRANSPORT,
                        transportId: this.recvTransport.id,
                        dtlsParameters
                    });
                    callback();
                    log('Receive transport connected to server.', 'info');
                } catch (error) {
                    log(`Error connecting receive transport: ${error.message}`, 'error');
                    errback(error);
                }
            });

            this.recvTransport.on('connectionstatechange', (state) => {
                log(`Receive transport connection state changed: ${state}`, 'debug');
                 if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                    log(`Receive transport entered critical state: ${state}.`, 'warn');
                }
            });

        } catch (error) {
            log(`Error creating receive transport: ${error.message}`, 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: Could not create receive transport - ${error.message}`);
            this._handleConnectionFailure(); 
        }
    }

    disconnect(showNotification = true) {
        // ... (disconnect method remains largely the same, ensure remoteUserStreams is cleared)
        log('Disconnecting from MediaSoup server...', 'info');
        this.isConnecting = false;

        this.stopLocalAudio(false); 
        this.stopLocalVideo(false);

        if (this.socket) {
            this.socket.onopen = null; this.socket.onmessage = null; this.socket.onerror = null; this.socket.onclose = null;
            if (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING) this.socket.close();
            this.socket = null;
        }
        this.producers.forEach(p => { if (p && !p.closed) p.close(); }); this.producers.clear();
        
        // Clear consumers and associated UI
        this.consumers.forEach(consumer => {
            if (consumer && !consumer.closed) consumer.close();
            // UI cleanup for consumer is handled in _handleRemoteProducerClosed or here if direct
            const userStreamData = Array.from(this.remoteUserStreams.entries()).find(
                ([uid, data]) => data.audioConsumerId === consumer.id || data.videoConsumerId === consumer.id
            );
            if (userStreamData) {
                const userId = userStreamData[0];
                if (consumer.kind === MEDIA_KIND_AUDIO) $(`#mediasoup-consumer-audio-${userId}`).remove();
                else if (consumer.kind === MEDIA_KIND_VIDEO) this._removeRemoteVideoElement(userId);
            }
        });
        this.consumers.clear();
        this.remoteUserStreams.clear();


        if (this.sendTransport && !this.sendTransport.closed) { this.sendTransport.close(); this.sendTransport = null; }
        if (this.recvTransport && !this.recvTransport.closed) { this.recvTransport.close(); this.recvTransport = null; }
        this.device = null;
        this.requestMap.forEach(({ reject }) => reject(new Error('Disconnecting.'))); this.requestMap.clear();
        this.requestIdCounter = 0;

        if (this.localAudioStream) {
            this.localAudioStream.getTracks().forEach(track => track.stop());
            this.localAudioStream = null;
        }
        if (this.localVideoStream) {
            this.localVideoStream.getTracks().forEach(track => track.stop());
            this.localVideoStream = null;
        }
        this._removeLocalVideoPreview();


        if (this.isConnected && showNotification) {
            ui.notifications.info(`${MODULE_TITLE}: Disconnected from MediaSoup server.`);
        }
        this.isConnected = false;
        this._updateConnectionStatus('disconnected');
        ui.players.render(true); // Re-render player list to remove A/V elements
    }

    _updateConnectionStatus(status) { /* ... (no changes) ... */ 
        log(`Connection status updated to: ${status}`, 'info');
        const connectButton = $('#controls ol.main-controls li[data-tool="' + MODULE_ID + '-toggle"]'); 
        if (connectButton.length) {
            const icon = connectButton.find('i');
            switch (status) {
                case 'connected':
                    icon.removeClass('fa-headset fa-spin fa-exclamation-triangle').addClass('fa-link');
                    connectButton.attr('title', 'Disconnect MediaSoup A/V');
                    connectButton.addClass('active');
                    break;
                case 'connecting':
                    icon.removeClass('fa-headset fa-link fa-exclamation-triangle').addClass('fa-spin fa-headset');
                    connectButton.attr('title', 'Connecting MediaSoup A/V...');
                    connectButton.removeClass('active');
                    break;
                case 'disconnected':
                    icon.removeClass('fa-link fa-spin fa-exclamation-triangle').addClass('fa-headset');
                    connectButton.attr('title', 'Connect MediaSoup A/V');
                    connectButton.removeClass('active');
                    break;
                case 'error':
                    icon.removeClass('fa-link fa-spin fa-headset').addClass('fa-exclamation-triangle');
                    connectButton.attr('title', 'Connection Error - Click to Retry MediaSoup A/V');
                    connectButton.removeClass('active');
                    break;
            }
        }
        // Show/hide media control buttons based on connection status
        $(`li[data-group="${MODULE_ID}-controls"]`).not(`[data-tool="${MODULE_ID}-toggle"]`).toggle(status === 'connected');
        if (status !== 'connected') { // If not connected, ensure local preview is removed
            this._removeLocalVideoPreview();
        }
    }
    async _populateDeviceSettings() { /* ... (no changes) ... */ 
        log('Populating device settings...', 'debug');
        try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                log('enumerateDevices() not supported.', 'warn');
                return;
            }
            // Request temporary permission to get device labels if not already granted
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                tempStream.getTracks().forEach(track => track.stop());
            } catch (permErr) {
                log('Could not get temporary stream for device labels. Labels might be missing if permissions not granted.', 'debug');
            }

            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputDevices = {'default': 'Browser Default'}; // Start with default
            const videoInputDevices = {'default': 'Browser Default'}; // Start with default

            devices.forEach(device => {
                if (device.deviceId === 'default' || device.deviceId === '') return; // Skip default device if it appears separately
                if (device.kind === 'audioinput') {
                    audioInputDevices[device.deviceId] = device.label || `Microphone ${Object.keys(audioInputDevices).length}`;
                } else if (device.kind === 'videoinput') {
                    videoInputDevices[device.deviceId] = device.label || `Webcam ${Object.keys(videoInputDevices).length}`;
                }
            });

            this.availableAudioDevices = audioInputDevices;
            this.availableVideoDevices = videoInputDevices;
            log('Available audio devices:', 'debug', JSON.stringify(this.availableAudioDevices));
            log('Available video devices:', 'debug', JSON.stringify(this.availableVideoDevices));
            
            const audioSetting = game.settings.settings.get(`${MODULE_ID}.${SETTING_DEFAULT_AUDIO_DEVICE}`);
            if (audioSetting) audioSetting.choices = audioInputDevices; else log(`Setting ${SETTING_DEFAULT_AUDIO_DEVICE} not found`, "warn");
            
            const videoSetting = game.settings.settings.get(`${MODULE_ID}.${SETTING_DEFAULT_VIDEO_DEVICE}`);
            if (videoSetting) videoSetting.choices = videoInputDevices; else log(`Setting ${SETTING_DEFAULT_VIDEO_DEVICE} not found`, "warn");
            
            if (ui.menu.activeMenu === "settings" && $(".tab[data-tab='modules']").hasClass("active") && $(`section[data-tab="modules"] .module-settings details[data-module-id="${MODULE_ID}"]`).attr('open')) {
                const settingsApp = Object.values(ui.windows).find(app => app instanceof SettingsConfig && app.element.find(`details[data-module-id="${MODULE_ID}"]`).length);
                if (settingsApp) settingsApp.render(false); // Re-render the settings config app
                log("Attempting to re-render settings after populating devices.", "debug");
            }
        } catch (err) {
            log(`Error enumerating devices: ${err.message}`, 'error');
        }
    }
    async startLocalAudio() { /* ... (no changes) ... */ 
        if (!this.isConnected || !this.sendTransport || !this.device.canProduce(MEDIA_KIND_AUDIO)) {
            log('Cannot start local audio: Not connected, send transport not ready, or cannot produce audio.', 'warn');
            ui.notifications.warn(`${MODULE_TITLE}: Cannot start audio. Not ready.`);
            return;
        }
        if (this.producers.has(APP_DATA_TAG_MIC)) {
            log('Audio already started.', 'info');
            const producer = this.producers.get(APP_DATA_TAG_MIC);
            if (producer.paused) await this.resumeProducer(producer);
            return;
        }

        log('Starting local audio capture...', 'info');
        try {
            const deviceId = game.settings.get(MODULE_ID, SETTING_DEFAULT_AUDIO_DEVICE);
            const constraints = { audio: deviceId && deviceId !== 'default' ? { deviceId: { exact: deviceId } } : true };
            log(`Using audio constraints: ${JSON.stringify(constraints)}`, 'debug');

            this.localAudioStream = await navigator.mediaDevices.getUserMedia(constraints);
            const track = this.localAudioStream.getAudioTracks()[0];
            if (!track) throw new Error("No audio track found in stream.");

            const producer = await this.sendTransport.produce({
                track,
                appData: { mediaTag: APP_DATA_TAG_MIC, userId: game.userId } 
            });
            this.producers.set(APP_DATA_TAG_MIC, producer);
            log(`Audio producer created (ID: ${producer.id})`, 'info');
            this._updateMediaButtonState(APP_DATA_TAG_MIC, true, producer.paused);

            producer.on('trackended', () => {
                log('Audio track ended (e.g., device unplugged).', 'warn');
                this.stopLocalAudio(true); 
            });
            producer.on('transportclose', () => {
                log('Audio producer transport closed.', 'warn');
                this.producers.delete(APP_DATA_TAG_MIC);
                this._updateMediaButtonState(APP_DATA_TAG_MIC, false, false);
                 if (this.localAudioStream) { // Ensure stream is cleaned up
                    this.localAudioStream.getTracks().forEach(t => t.stop());
                    this.localAudioStream = null;
                }
            });

        } catch (error) {
            log(`Error starting local audio: ${error.message}`, 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: Could not start microphone - ${error.message}`);
            if (this.localAudioStream) { this.localAudioStream.getTracks().forEach(t => t.stop()); this.localAudioStream = null; }
        }
    }
    async stopLocalAudio(notifyServer = true) { /* ... (no changes) ... */ 
        const producer = this.producers.get(APP_DATA_TAG_MIC);
        if (!producer) {
            log('No local audio producer to stop.', 'debug');
            return;
        }
        log('Stopping local audio...', 'info');
        if (!producer.closed) {
            producer.close(); 
        }
        // producer.on('transportclose') should handle deleting from map and updating UI
        // but if it doesn't fire reliably or quickly enough:
        if (this.producers.has(APP_DATA_TAG_MIC)) {
            this.producers.delete(APP_DATA_TAG_MIC);
            this._updateMediaButtonState(APP_DATA_TAG_MIC, false, false);
        }


        if (this.localAudioStream) {
            this.localAudioStream.getTracks().forEach(track => track.stop());
            this.localAudioStream = null;
        }
        if (notifyServer && this.socket && this.socket.readyState === WebSocket.OPEN && producer && !producer.closed) { // Check if producer exists for ID
             try {
                // Server should detect producer.close() via mediasoup's events. Explicit signal might be redundant.
                // await this._sendSignalingRequest({ type: SIG_MSG_TYPES.PRODUCER_CLOSED, producerId: producer.id });
             } catch (e) { log(`Error notifying server of audio producer close: ${e.message}`, 'warn');}
        }
    }
    async toggleAudioMute() { /* ... (no changes) ... */ 
        const producer = this.producers.get(APP_DATA_TAG_MIC);
        if (!producer || producer.closed) {
            log('Cannot toggle mute: No active audio producer. Attempting to start audio.', 'info');
            await this.startLocalAudio(); // Attempt to start if not active
            return;
        }
        if (producer.paused) {
            await this.resumeProducer(producer);
        } else {
            await this.pauseProducer(producer);
        }
    }
    async startLocalVideo() { /* ... (no changes) ... */ 
        if (!this.isConnected || !this.sendTransport || !this.device.canProduce(MEDIA_KIND_VIDEO)) {
            log('Cannot start local video: Not connected, send transport not ready, or cannot produce video.', 'warn');
            ui.notifications.warn(`${MODULE_TITLE}: Cannot start video. Not ready.`);
            return;
        }
         if (this.producers.has(APP_DATA_TAG_WEBCAM)) {
            log('Video already started.', 'info');
            const producer = this.producers.get(APP_DATA_TAG_WEBCAM);
            if (producer.paused) await this.resumeProducer(producer);
            return;
        }

        log('Starting local video capture...', 'info');
        try {
            const deviceId = game.settings.get(MODULE_ID, SETTING_DEFAULT_VIDEO_DEVICE);
            const constraints = { video: deviceId && deviceId !== 'default' ? { deviceId: { exact: deviceId } } : true };
            log(`Using video constraints: ${JSON.stringify(constraints)}`, 'debug');

            this.localVideoStream = await navigator.mediaDevices.getUserMedia(constraints);
            const track = this.localVideoStream.getVideoTracks()[0];
            if (!track) throw new Error("No video track found in stream.");

            const producer = await this.sendTransport.produce({
                track,
                encodings: [],
                appData: { mediaTag: APP_DATA_TAG_WEBCAM, userId: game.userId }
            });
            this.producers.set(APP_DATA_TAG_WEBCAM, producer);
            log(`Video producer created (ID: ${producer.id})`, 'info');
            this._updateMediaButtonState(APP_DATA_TAG_WEBCAM, true, producer.paused);
            this._displayLocalVideoPreview(this.localVideoStream);


            producer.on('trackended', () => {
                log('Video track ended.', 'warn');
                this.stopLocalVideo(true);
            });
            producer.on('transportclose', () => {
                log('Video producer transport closed.', 'warn');
                this.producers.delete(APP_DATA_TAG_WEBCAM);
                this._updateMediaButtonState(APP_DATA_TAG_WEBCAM, false, false);
                this._removeLocalVideoPreview();
                if (this.localVideoStream) { // Ensure stream is cleaned up
                    this.localVideoStream.getTracks().forEach(t => t.stop());
                    this.localVideoStream = null;
                }
            });

        } catch (error) {
            log(`Error starting local video: ${error.message}`, 'error', true);
            ui.notifications.error(`${MODULE_TITLE}: Could not start webcam - ${error.message}`);
            if (this.localVideoStream) { this.localVideoStream.getTracks().forEach(t => t.stop()); this.localVideoStream = null; }
            this._removeLocalVideoPreview();
        }
    }
    async stopLocalVideo(notifyServer = true) { /* ... (no changes) ... */ 
        const producer = this.producers.get(APP_DATA_TAG_WEBCAM);
        if (!producer) {
            log('No local video producer to stop.', 'debug');
            return;
        }
        log('Stopping local video...', 'info');
        if (!producer.closed) {
            producer.close();
        }
        // producer.on('transportclose') should handle deleting from map and updating UI
        if (this.producers.has(APP_DATA_TAG_WEBCAM)) {
            this.producers.delete(APP_DATA_TAG_WEBCAM);
            this._updateMediaButtonState(APP_DATA_TAG_WEBCAM, false, false);
        }
        

        if (this.localVideoStream) {
            this.localVideoStream.getTracks().forEach(track => track.stop());
            this.localVideoStream = null;
        }
        this._removeLocalVideoPreview();

        if (notifyServer && this.socket && this.socket.readyState === WebSocket.OPEN && producer && !producer.closed) {
            // Server should detect producer.close() via mediasoup's events.
            // try {
            //    await this._sendSignalingRequest({ type: SIG_MSG_TYPES.PRODUCER_CLOSED, producerId: producer.id });
            // } catch (e) { log(`Error notifying server of video producer close: ${e.message}`, 'warn');}
        }
    }
    async toggleVideoEnabled() { /* ... (no changes) ... */ 
        const producer = this.producers.get(APP_DATA_TAG_WEBCAM);
        if (!producer || producer.closed) { 
            log('No active video producer to toggle. Attempting to start video.', 'info');
            await this.startLocalVideo();
            return;
        }
        if (producer.paused) {
            await this.resumeProducer(producer);
            this._displayLocalVideoPreview(this.localVideoStream); 
        } else { 
            await this.pauseProducer(producer);
            this._removeLocalVideoPreview(); 
        }
    }
    async pauseProducer(producer) { /* ... (no changes) ... */ 
        if (!producer || producer.closed || producer.paused) return;
        log(`Pausing producer ${producer.id} (Kind: ${producer.kind}, AppData: ${JSON.stringify(producer.appData)})`, 'info');
        try {
            await producer.pause();
            log(`Producer ${producer.id} paused.`, 'info');
            this._updateMediaButtonState(producer.appData.mediaTag, true, true);
             // Notify server that producer is paused
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this._sendSignalingRequest({ type: SIG_MSG_TYPES.PAUSE_PRODUCER, producerId: producer.id })
                    .catch(e => log(`Error notifying server of producer pause: ${e.message}`, 'warn'));
            }
        } catch (error) {
            log(`Error pausing producer ${producer.id}: ${error.message}`, 'error');
        }
    }
    async resumeProducer(producer) { /* ... (no changes) ... */ 
        if (!producer || producer.closed || !producer.paused) return;
        log(`Resuming producer ${producer.id} (Kind: ${producer.kind}, AppData: ${JSON.stringify(producer.appData)})`, 'info');
        try {
            await producer.resume();
            log(`Producer ${producer.id} resumed.`, 'info');
            this._updateMediaButtonState(producer.appData.mediaTag, true, false);
            // Notify server that producer is resumed
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                 this._sendSignalingRequest({ type: SIG_MSG_TYPES.RESUME_PRODUCER, producerId: producer.id })
                    .catch(e => log(`Error notifying server of producer resume: ${e.message}`, 'warn'));
            }
        } catch (error) {
            log(`Error resuming producer ${producer.id}: ${error.message}`, 'error');
        }
    }
    _updateMediaButtonState(mediaTag, isActive, isPaused) { /* ... (no changes) ... */ 
        const button = $(`#controls ol.main-controls li[data-tool="${MODULE_ID}-media-${mediaTag}"]`);
        if (!button.length) return;

        const icon = button.find('i');
        if (isActive) {
            button.addClass('active'); // Indicates the producer exists
            if (mediaTag === APP_DATA_TAG_MIC) {
                icon.removeClass(isPaused ? 'fa-microphone' : 'fa-microphone-slash').addClass(isPaused ? 'fa-microphone-slash' : 'fa-microphone');
                button.attr('title', isPaused ? 'Unmute Microphone' : 'Mute Microphone');
            } else if (mediaTag === APP_DATA_TAG_WEBCAM) {
                icon.removeClass(isPaused ? 'fa-video' : 'fa-video-slash').addClass(isPaused ? 'fa-video-slash' : 'fa-video');
                button.attr('title', isPaused ? 'Turn Camera On' : 'Turn Camera Off');
            }
        } else { // Producer does not exist or is closed
            button.removeClass('active');
            if (mediaTag === APP_DATA_TAG_MIC) {
                icon.removeClass('fa-microphone-slash').addClass('fa-microphone');
                button.attr('title', 'Start Microphone');
            } else if (mediaTag === APP_DATA_TAG_WEBCAM) {
                icon.removeClass('fa-video-slash').addClass('fa-video');
                button.attr('title', 'Start Camera');
            }
        }
    }
    _displayLocalVideoPreview(stream) { /* ... (no changes) ... */ 
        if (!stream) return;
        let previewElement = $('#mediasoup-local-video-preview');
        if (!previewElement.length) {
            previewElement = $('<video id="mediasoup-local-video-preview" autoplay muted playsinline class="rounded-lg shadow-lg mediasoup-video-preview"></video>');
            $('body').append(previewElement);
        }
        previewElement.get(0).srcObject = stream;
        previewElement.show();
        log("Local video preview displayed.", "debug");
    }
    _removeLocalVideoPreview() { /* ... (no changes) ... */ 
        const previewElement = $('#mediasoup-local-video-preview');
        if (previewElement.length && previewElement.get(0).srcObject) {
             previewElement.get(0).srcObject.getTracks().forEach(track => track.stop());
        }
        previewElement.remove(); 
        log("Local video preview removed.", "debug");
    }

    // --- Remote Media Management (FR-RMM) ---
    async _handleNewRemoteProducer({ producerId, userId, kind, appData }) {
        if (userId === game.userId) {
            log(`Skipping consumption of own producer ${producerId}`, 'debug');
            return;
        }
        // Ensure appData from server notification contains rtpParameters for consumption
        if (!appData || !appData.rtpParameters) {
            log(`Cannot consume producer ${producerId}: Missing rtpParameters in appData from server notification.`, 'error');
            return;
        }

        // Check if we can consume this producer
        if (!this.isConnected || !this.recvTransport || !this.device.canConsume({ producerId, kind, rtpParameters: appData.rtpParameters })) {
            log(`Cannot consume new producer ${producerId}: Not ready or device cannot consume. Device consumable check failed.`, 'warn');
            return;
        }
        log(`Handling new remote producer ${producerId} of kind ${kind} from user ${userId}`, 'info');

        try {
            // Send 'consume' request to server
            const consumerParams = await this._sendSignalingRequest({
                type: SIG_MSG_TYPES.CONSUME,
                producerId: producerId,
                rtpCapabilities: this.device.rtpCapabilities, // Client's RTP capabilities for receiving
                // transportId: this.recvTransport.id // Server might pick based on producerId
            });

            if (!consumerParams || !consumerParams.id) {
                throw new Error('Server did not return valid consumer parameters.');
            }

            const consumer = await this.recvTransport.consume({
                id: consumerParams.id, // Consumer ID from server
                producerId: consumerParams.producerId,
                kind: consumerParams.kind,
                rtpParameters: consumerParams.rtpParameters, // RTP parameters from server for this consumer
                appData: { ...appData, userId, kind } // Store original appData plus userId and kind
            });

            this.consumers.set(consumer.id, consumer);
            log(`Consumer created (ID: ${consumer.id}, Kind: ${kind}) for producer ${producerId}`, 'info');

            // Store track and consumer ID with user
            let userStreams = this.remoteUserStreams.get(userId) || {};
            if (kind === MEDIA_KIND_AUDIO) {
                userStreams.audioTrack = consumer.track;
                userStreams.audioConsumerId = consumer.id;
                const audioElement = document.createElement('audio');
                audioElement.id = `mediasoup-consumer-audio-${userId}`; // Use userId for simpler lookup
                audioElement.srcObject = new MediaStream([consumer.track]);
                audioElement.autoplay = true;
                document.body.appendChild(audioElement);
                log(`Playing remote audio for user ${userId}, consumer ${consumer.id}`, 'debug');
            } else if (kind === MEDIA_KIND_VIDEO) {
                userStreams.videoTrack = consumer.track;
                userStreams.videoConsumerId = consumer.id;
                log(`Received remote video track for user ${userId}, consumer ${consumer.id}. Attaching to UI.`, 'info');
                // UI update will be handled by renderPlayerList hook based on remoteUserStreams
            }
            this.remoteUserStreams.set(userId, userStreams);

            // If producer is initially paused server-side, client consumer might also need to be paused
            if (consumerParams.producerPaused) { // Assuming server sends this if producer is paused
                log(`Remote producer ${producerId} is paused. Pausing consumer ${consumer.id}.`, 'info');
                // Consumer might start paused by default if producer is paused, or might need explicit consumer.pause()
                // For now, we assume mediasoup-client handles this based on server signaling or track state.
            }


            consumer.on('trackended', () => {
                log(`Remote track ended for consumer ${consumer.id}.`, 'warn');
                this._handleRemoteProducerClosed(consumer.producerId);
            });
            consumer.on('transportclose', () => {
                log(`Consumer transport closed for consumer ${consumer.id}.`, 'warn');
                this._handleRemoteProducerClosed(consumer.producerId);
            });

            // Trigger player list re-render to show new video/audio status
            ui.players.render(true);

        } catch (error) {
            log(`Error consuming producer ${producerId}: ${error.message}`, 'error', true);
            console.error(error);
        }
    }

    _handleRemoteProducerClosed(producerId) {
        let consumerToClose = null;
        let consumerIdToRemove = null;

        for (const [cId, c] of this.consumers) {
            if (c.producerId === producerId) {
                consumerToClose = c;
                consumerIdToRemove = cId;
                break;
            }
        }

        if (consumerToClose) {
            log(`Closing consumer ${consumerToClose.id} for remote producer ${producerId}`, 'info');
            if (!consumerToClose.closed) {
                consumerToClose.close();
            }
            this.consumers.delete(consumerIdToRemove);

            const userId = consumerToClose.appData.userId;
            const kind = consumerToClose.kind;
            let userStreams = this.remoteUserStreams.get(userId);

            if (userStreams) {
                if (kind === MEDIA_KIND_AUDIO) {
                    $(`#mediasoup-consumer-audio-${userId}`).remove();
                    userStreams.audioTrack = null;
                    userStreams.audioConsumerId = null;
                } else if (kind === MEDIA_KIND_VIDEO) {
                    this._removeRemoteVideoElement(userId); // UI cleanup
                    userStreams.videoTrack = null;
                    userStreams.videoConsumerId = null;
                }
                if (!userStreams.audioTrack && !userStreams.videoTrack) {
                    this.remoteUserStreams.delete(userId);
                } else {
                    this.remoteUserStreams.set(userId, userStreams);
                }
            }
            ui.players.render(true); // Re-render player list
        } else {
            log(`No active consumer found for producerId ${producerId} to close.`, 'debug');
        }
    }

    _getOrCreateRemoteVideoElement(userId) {
        const playerId = `player-${userId}`; // Assuming player list item has id like player-<userId>
        let playerLi = $(`#player-list li#${playerId}`);
        if (!playerLi.length) { // Fallback if player list structure is different or user not in list
            playerLi = $(`#player-list li[data-user-id="${userId}"]`); // Foundry default
        }


        let videoContainer = playerLi.find('.mediasoup-video-container');
        if (!videoContainer.length) {
            // Insert after player name, or at a specific point in playerLi
            videoContainer = $('<div class="mediasoup-video-container"></div>');
            playerLi.find('.player-name').after(videoContainer); // Example placement
        }

        let videoElement = videoContainer.find('video.mediasoup-remote-video');
        if (!videoElement.length) {
            videoElement = $(`<video id="mediasoup-remote-video-${userId}" class="mediasoup-remote-video" autoplay playsinline></video>`);
            videoContainer.append(videoElement);
        }
        return videoElement.get(0);
    }

    _removeRemoteVideoElement(userId) {
        const playerLi = $(`#player-list li[data-user-id="${userId}"]`);
        playerLi.find('.mediasoup-video-container').remove(); // Remove the whole container
        // Also remove any standalone audio elements if not handled elsewhere
        $(`#mediasoup-consumer-audio-${userId}`).remove();
    }
}

// Global instance of our client
let mediaSoupVTTClientInstance = null;


// +-------------------------------------------------------------------+
// |                        FOUNDRY VTT HOOKS                          |
// +-------------------------------------------------------------------+
Hooks.once('init', () => {
    log('Initializing MediaSoupVTT Plugin...', 'info', true);

    game.settings.register(MODULE_ID, SETTING_DEBUG_LOGGING, {
        name: `${MODULE_TITLE} Debug Logging`,
        hint: 'Outputs verbose logging to the console for debugging purposes.',
        scope: 'client', config: true, type: Boolean, default: false,
    });
    game.settings.register(MODULE_ID, SETTING_MEDIASOUP_URL, {
        name: 'MediaSoup Server WebSocket URL',
        hint: 'The WebSocket URL (e.g., wss://your.server.com:4443). Required.',
        scope: 'world', config: true, type: String, default: '',
        onChange: value => {
            log(`MediaSoup Server URL changed to: ${value}`);
            if (mediaSoupVTTClientInstance) {
                mediaSoupVTTClientInstance.serverUrl = value;
                if (mediaSoupVTTClientInstance.isConnected || mediaSoupVTTClientInstance.isConnecting) {
                    mediaSoupVTTClientInstance.disconnect();
                    ui.notifications.info(`${MODULE_TITLE}: Server URL changed. Disconnected. Please reconnect manually.`);
                }
            }
        }
    });
    game.settings.register(MODULE_ID, SETTING_AUTO_CONNECT, {
        name: 'Auto-connect to MediaSoup Server',
        hint: 'If checked, attempts to connect automatically when you join a game world.',
        scope: 'client', config: true, type: Boolean, default: true,
    });
    game.settings.register(MODULE_ID, SETTING_DEFAULT_AUDIO_DEVICE, {
        name: 'Default Microphone',
        hint: 'Select preferred microphone. List populates after connecting or opening settings. May need page reload after first permission grant for all labels.',
        scope: 'client', config: true, type: String, default: 'default', choices: {'default': 'Browser Default'}
    });
    game.settings.register(MODULE_ID, SETTING_DEFAULT_VIDEO_DEVICE, {
        name: 'Default Webcam',
        hint: 'Select preferred webcam. List populates after connecting or opening settings. May need page reload after first permission grant for all labels.',
        scope: 'client', config: true, type: String, default: 'default', choices: {'default': 'Browser Default'}
    });

    Hooks.on('renderSettingsConfig', async (app, html, data) => {
        if (mediaSoupVTTClientInstance && app.constructor.name === "SettingsConfig") {
            const moduleDetails = html.find(`details[data-module-id="${MODULE_ID}"]`);
            if (moduleDetails.length && (moduleDetails.attr('open') !== undefined || !mediaSoupVTTClientInstance.availableAudioDevices)) {
                 log("SettingsConfig rendered for our module, attempting to populate device lists.", "debug");
                 await mediaSoupVTTClientInstance._populateDeviceSettings();
                 // Forcing a re-render of the settings app if choices were updated
                 if (app.element && app.element.length) { // Check if app is rendered
                    const currentScroll = app.element.find('.scrollable').scrollTop(); // Preserve scroll
                    app.render(false, {focus: false}); // Re-render without stealing focus
                    app.element.find('.scrollable').scrollTop(currentScroll); // Restore scroll
                 }
            }
        }
    });

    // Add CSS for video elements
    const styles = `
        .mediasoup-video-container {
            max-width: 160px; /* Max width of player list item */
            max-height: 120px; /* Max height */
            margin-top: 5px;
            overflow: hidden;
            border-radius: 4px;
            background-color: #111; /* Dark background for video area */
        }
        .mediasoup-remote-video, .mediasoup-video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the area, might crop */
            display: block;
        }
        .mediasoup-video-preview { /* Styles for local preview */
             position: fixed;
             bottom: 70px; /* Above hotbar */
             right: 20px;
             width: 200px; 
             height: 150px;
             border: 2px solid #555;
             background-color: black;
             z-index: 1050; /* High z-index */
             box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #player-list .player .player-name { /* Ensure player name is visible above video */
            position: relative;
            z-index: 1;
        }
    `;
    $('head').append(`<style id="mediasoup-vtt-styles">${styles}</style>`);
});

Hooks.once('ready', async () => {
    log('Foundry VTT is ready. MediaSoupVTT is active.', 'info', true);
    if (!window.mediasoupClient) {
        ui.notifications.error(`${MODULE_TITLE}: mediasoup-client library was not found. Plugin will not function.`, { permanent: true });
        return;
    }
    mediaSoupVTTClientInstance = new MediaSoupVTTClient();
    window.MediaSoupVTT_Client = mediaSoupVTTClientInstance;

    const autoConnect = game.settings.get(MODULE_ID, SETTING_AUTO_CONNECT);
    if (autoConnect && mediaSoupVTTClientInstance.serverUrl) {
        log('Auto-connecting to MediaSoup server...');
        try { await mediaSoupVTTClientInstance.connect(); }
        catch (err) { log(`Auto-connect initial attempt failed: ${err.message}`, 'error'); }
    } else if (autoConnect && !mediaSoupVTTClientInstance.serverUrl) {
        log('Auto-connect enabled, but server URL is not set. Skipping connection.', 'warn');
        ui.notifications.warn(`${MODULE_TITLE}: Auto-connect is on, but server URL is not set.`);
    } else {
        if (navigator.permissions && navigator.permissions.query) {
            try {
                const micPerm = await navigator.permissions.query({name: 'microphone'});
                const camPerm = await navigator.permissions.query({name: 'camera'});
                if (micPerm.state === 'granted' || camPerm.state === 'granted') {
                    await mediaSoupVTTClientInstance._populateDeviceSettings();
                }
            } catch (e) { log("Error querying permissions on ready: " + e.message, "warn"); }
        }
    }
});

Hooks.on('getSceneControlButtons', (controls) => {
    // Ensure the group exists
    let avControlsGroup = controls.find(c => c.name === `${MODULE_ID}-controls`);
    if (!avControlsGroup) {
        avControlsGroup = {
            name: `${MODULE_ID}-controls`,
            title: 'MediaSoup A/V',
            layer: `${MODULE_ID}-layer`,
            icon: 'fas fa-network-wired',
            tools: [],
            activeTool: ''
        };
        controls.push(avControlsGroup);
    } else { // Clear existing tools to prevent duplication on hot reload
        avControlsGroup.tools = [];
    }


    const commonOnClick = async (action) => { /* ... (no changes) ... */ 
        if (!mediaSoupVTTClientInstance) {
            ui.notifications.error(`${MODULE_TITLE}: Client not ready.`); return;
        }
        if (!mediaSoupVTTClientInstance.isConnected && !['connect', 'disconnect'].includes(action)) { // Allow disconnect even if not fully "connected" but trying
             ui.notifications.warn(`${MODULE_TITLE}: Not connected to MediaSoup server.`); return;
        }
        try {
            switch (action) {
                case 'connect':
                    if (mediaSoupVTTClientInstance.isConnected || mediaSoupVTTClientInstance.isConnecting) mediaSoupVTTClientInstance.disconnect();
                    else if (!mediaSoupVTTClientInstance.serverUrl) ui.notifications.warn(`${MODULE_TITLE}: Server URL not set.`);
                    else await mediaSoupVTTClientInstance.connect();
                    break;
                case 'toggleAudio': await mediaSoupVTTClientInstance.toggleAudioMute(); break;
                case 'toggleVideo': await mediaSoupVTTClientInstance.toggleVideoEnabled(); break;
            }
        } catch (error) {
            log(`Error in scene control action '${action}': ${error.message}`, 'error');
            ui.notifications.error(`${MODULE_TITLE}: Action failed - ${error.message}`);
        }
    };
    
    avControlsGroup.tools.push(
        { name: MODULE_ID + '-toggle', title: 'Connect MediaSoup A/V', icon: 'fas fa-headset', onClick: () => commonOnClick('connect'), button: true, 'data-tool': MODULE_ID + '-toggle' },
        { name: MODULE_ID + '-media-mic', title: 'Start Microphone', icon: 'fas fa-microphone', onClick: () => commonOnClick('toggleAudio'), button: true, visible: false, 'data-tool': `${MODULE_ID}-media-mic` },
        { name: MODULE_ID + '-media-webcam', title: 'Start Webcam', icon: 'fas fa-video', onClick: () => commonOnClick('toggleVideo'), button: true, visible: false, 'data-tool': `${MODULE_ID}-media-webcam` }
    );
     // Update visibility after adding, in case status is already connected from a previous load
    if (mediaSoupVTTClientInstance) {
        mediaSoupVTTClientInstance._updateConnectionStatus(mediaSoupVTTClientInstance.isConnected ? 'connected' : (mediaSoupVTTClientInstance.isConnecting ? 'connecting' : 'disconnected'));
        if (mediaSoupVTTClientInstance.isConnected) {
            mediaSoupVTTClientInstance._updateMediaButtonState(APP_DATA_TAG_MIC, mediaSoupVTTClientInstance.producers.has(APP_DATA_TAG_MIC), mediaSoupVTTClientInstance.producers.get(APP_DATA_TAG_MIC)?.paused);
            mediaSoupVTTClientInstance._updateMediaButtonState(APP_DATA_TAG_WEBCAM, mediaSoupVTTClientInstance.producers.has(APP_DATA_TAG_WEBCAM), mediaSoupVTTClientInstance.producers.get(APP_DATA_TAG_WEBCAM)?.paused);
        }
    }
});

/**
 * Hook into rendering the player list to add video elements.
 * FR-RMM-004, FR-UIX-002
 */
Hooks.on('renderPlayerList', (playerListApp, html, data) => {
    if (!mediaSoupVTTClientInstance || !mediaSoupVTTClientInstance.isConnected) {
        // Clean up any existing video elements if not connected
        html.find('.mediasoup-video-container').remove();
        return;
    }

    log('Rendering player list. Updating A/V elements.', 'debug');

    html.find('li.player').each((index, playerLiElement) => {
        const playerLi = $(playerLiElement);
        const userId = playerLi.data('user-id');
        if (!userId) return;

        // Remove old container first to ensure clean update
        playerLi.find('.mediasoup-video-container').remove();

        const userStreams = mediaSoupVTTClientInstance.remoteUserStreams.get(userId);

        if (userStreams && userStreams.videoTrack) {
            log(`User ${userId} has a video track. Creating video element.`, 'debug');
            const videoContainer = $('<div class="mediasoup-video-container"></div>');
            const videoElement = $(`<video id="mediasoup-remote-video-${userId}" class="mediasoup-remote-video" autoplay playsinline muted></video>`); // Mute remote videos by default to prevent echo if user is also producing
            
            try {
                videoElement.get(0).srcObject = new MediaStream([userStreams.videoTrack]);
            } catch (e) {
                log(`Error setting srcObject for user ${userId}: ${e.message}`, 'error');
            }
            
            videoContainer.append(videoElement);
            // Find a good place to append, e.g., after player name or avatar
            const playerNameElement = playerLi.find('.player-name');
            if (playerNameElement.length) {
                playerNameElement.after(videoContainer);
            } else {
                playerLi.append(videoContainer); // Fallback
            }
        }
        // Add speaking indicator or mute status later
    });
});


log('MediaSoupVTT Plugin script loaded.');
